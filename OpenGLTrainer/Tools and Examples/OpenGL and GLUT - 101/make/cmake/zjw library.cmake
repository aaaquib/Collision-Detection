# \author Zachary Wartell
# \copyright Zachary Wartell, 2009
#
# This cmake file aims to conform to the definitions and build organization
# discussed in:
# 
#      svn://linux01.uncc.edu:3690/zwartell-public/ZJW Library/trunk/Programming Standards.doc

#
# By current convention this file is svn:external linked into the cmake
# subdirectories of software source distributions conforming to the above
# standards in the directory:
#
# 	DISTRIBUTION/make/cmake
#
# The file:
#
# 	DISTRIBUTION/make/cmake/CMakeLists.txt
# 
# is quite short following a simple pattern.  The guts of the distributions CMake script is in an
# separate CMakeLists.txt in a another directory such as:
#
#
# 	DISTRIBUTION/sources/CMakeLists.txt
#
# Circa 9/17/09, examples of this are in:
#
# - svn://linux01.uncc.edu:3690/zwartell-public/ITCS 6120-8120/OpenGLTrainer/trunk/
# - ... others ...

#
# CITATIONS: 
# - [R1] "svn://linux01.uncc.edu:3690/zwartell-public/ZJW Library/trunk/Programming Standards.doc"
#

## 
## Avoid executing "zjw library.cmake" multiple times when multiple recursively executed CMake scripts ## include() "zjw library.cmake" multiple times.
##

if(ZJW_LIBRARY_CMAKE)
    # in the current CMake execution zjw library.cmake was include'd once before, so
    # handle possible error of incompatible versions and return without further executing 
    # this script
    if(NOT ${ZJW_LIBRARY_CMAKE} STREQUAL "$Revision: 11565 $")
	zjw_handle_revision_error("$Revision: 11565 $")
    endif(NOT ${ZJW_LIBRARY_CMAKE} STREQUAL "$Revision: 11565 $")

    #message(STATUS "NTH:*****************************:\n ${CMAKE_SOURCE_DIR}")
    #message(STATUS "    $ENV{ZJWL_PACKAGE_LIST}")

    # otherwise return without continuing to execute script if it's already been
    # include()'d
    return()
else(ZJW_LIBRARY_CMAKE)
    # this is the first time in the current CMake execution zjw library.cmake was include'd,
    # so initialize variables and continue executing this script

    set(ENV{ZJWL_PACKAGE_LIST} "")  # use ENV to make a global variables that all scripts
    				    # executing in the same CMake execution can see
    set(ZJW_LIBRARY_CMAKE "$Revision: 11565 $")

endif(ZJW_LIBRARY_CMAKE)

##
## DEFINE FUNCTIONS 
##


# \function \author Zachary Wartell
#
# \warning zjw_handle_revision_error is not fully tested yet. It's mostly
# useful when developing/debugging "zjw library.cmake"
#
# \brief zjw_handle_revision_error handles the situation where a single
# execution of CMake recursively traverses directories with CMakeLists.txt and
# one of them include's an different version of "zjw library.cmake" than the
# others did.  If that occurs and if CMake variable zjw_auto_update is defined
# when invoking CMake, then zjw_handle_revision_error will attempt to svn
# update the copy of "zjw library.cmake" in the current directory. Otherwise, a
# fatal error is reported.  For more details see the text of the user messages
# generated by zjw_handle_revision_error below.
#

function(zjw_handle_revision_error
		REVISION 
	)
    if (DEFINED zjw_auto_update)
        get_filename_component(ZJW_DIR ${CMAKE_PARENT_LIST_FILE} ABSOLUTE)
        get_filename_component(ZJW_DIR ${ZJW_DIR} PATH)
	message(STATUS
		"Incompatible versions of 'zjw library.cmake' found\n"
	    "    including:\n"
	    "        ${REVISION}\n" 
	    "    and: \n"
	    "        ${ZJW_LIBRARY_CMAKE}\n"
	    "    Attempting svn update of file:\n"
	    "    	'${ZJW_DIR}/zjw library.cmake'\n"
		)
	execute_process (
	    COMMAND svn update "${ZJW_DIR}/zjw library.cmake"
	    OUTPUT_VARIABLE SVN_OUTPUT
	    ERROR_VARIABLE SVN_ERROR
	    RESULT_VARIABLE SVN_RESULT
	    )
	if(${SVN_RESULT} EQUAL 0)
	    message(STATUS "Svn update successful.")
	else(${SVN_RESULT} EQUAL 0)
	    message(FATAL_ERROR 
		"Svn update failed with:\n"
	    "           ${SVN_ERROR}\n"
	    "           ${SVN_OUTPUT}\n"
		)
	endif(${SVN_RESULT} EQUAL 0)

    else (DEFINED zjw_auto_update)
	message(FATAL_ERROR 
		"Incompatible versions of 'zjw library.cmake' found\n"
	    "    including:\n"
	    "        ${REVISION}\n" 
	    "    and: \n"
	    "        ${ZJW_LIBRARY_CMAKE}\n"
	    "    You should either:\n"
	    "        1) perform 'svn update' on all make/cmake directories manually to fix this problem.\n"
	    "	        (A single 'svn update' from your root working copy directory may be sufficient).\n"
	    "	        Then re-run CMake.\n"
	    "       OR\n"
	    "        2) Rerun CMake multiple times with the additional option:\n"
	    "\n"
	    "	        cmake -Dzjw_auto_update:string=true <your other parameters>\n"
	    "\n"
	    "           until all 'zjw library.cmake' scripts are successfully updated.\n"
	    "\n"
	    "           Then run CMake once more without the zjw_auto_update option to\n"
	    "		execute all the updated scripts."
		)
    endif (DEFINED zjw_auto_update)
endfunction(zjw_handle_revision_error)

#
# \function zjw_find_package 
# \author Zachary Wartell

#
# GOAL: combine aspects of CMake add_library and find_package and SVN
# functionality to checkout missing packages that conform to the ZJW package
# standard build organization (see [R1])
# 
# STATUS: Work in progress but working partially (see Section
# GOAL_zjw_find_package) 

# EXAMPLE CALL:
#
# zjw_find_package(glut 3.7.6.uncc-1
#   "svn:/linux01.uncc.edu:3690/zwartell-public/vendor/opengl/glut/"
#   "XP/VS80/Ix86/DLL_DEBUG" 
#   "../third party libraries"
#   )
#
# This will search the directory "..\third party libraries" for the package
# glut and the package must be:
#
#	- ZJW Library compliant ([R1])
#	- from SVN URL "svn:/linux01.uncc.edu:3690/zwartell-public/vendor/opengl/glut/"
#	- of version 3.7.6.uncc-1	    - [NOTE: Versioning NOT IMPLEMENTED yet]
#
# "XP/VS80/Ix86/DLL_DEBUG" is a sub-directory created for the current build configuration
# output files.  Generally, the actual arguement is the variable ${MAKE_CONFIG_PATH_SUFFIX}.

# GLOBAL VARIABLES (For Advanced Usage Only):
#
#   Recall global's can be passed to CMake using the CMake -D command-line option. The following
#   variables control behavior of "zjw_find_package". 
#
#   zjw_debug_log - a STRING, should be an integer indicate the level of debugging output.  0 is none.
#	Larger numbers generate more output.
#
#   zjw_ignore_version - a STRING, if defined zjw_find_package ignores mismatched VERSION or mismatched
#	SVN URL's.

# \warning Right now VERSION = 3.7.6.uncc-1 is ignored.
# \todo make partial implementation of VERSION

# ALGORITHM:
#
# IF directory "..\Third Party Libraries\${PACKAGE}\" exists
#
# 	IF directory "..\Third Party Libraries\${PACKAGE}\" is a working copy of:
#
#    	    	svn:/linux01.uncc.edu:3690/zwartell-public/vendor/opengl/glut/local/current
#
#	THEN 
#	        recursively execute CMake on "..\Third Party Libraries\${PACKAGE}\make\cmake 
#
#               set various Cmake variables in PARENT_SCOPE to refer to the package's appropriate
#		subdirectories (include/library/etc).  

#	        <EXPORT PARENT_SCOPE VARS>:
#
#               The Cmake file that called zjw_find_package then uses these variables in it's related 
#               CMake calls (see usage ...):
#
#		- ${PACKAGE}_INCLUDE_DIR  - directory path to include files for package ; usage include_directories
#		- ${PACKAGE}_LIBRARY_DIR  - directory path to library files for package ; usage link_directories
#		- ${PACKAGE}_LIBRARIES    - list of library files to link against       ; usage target_link_libraries 
# 		- ${PACKAGE}_DEFINITIONS  - list of C macro definitions to be		; usage add_definitions
# 					    passed to CMake add_definitions when using package
#		- ${PACKAGE}_FOUND	  - set to TRUE if conforming package was found with matching configuration
#			                    (Meant to be backward compatible with typical CMake find_package conventions).
#											; usage conditional tests
#		- ${PACKAGE}_DEPENDENCY_TARGET - name of target of add_library used to build this package's library.
#											; usage add_dependencies
							
#		Additionally, the variables below are used internally by "zjw library.cmake":
#
#		- ZJW_${PACKAGE}_FOUND	  - set to TRUE if conforming package was found with matching configuration 
#					    
#	ELSE IF not found
#		FATAL ERROR	
#		\todo request user to remove library copy that is non-conforming...

# ELSE IF the directory does not exist, 
#	SVN checkout the code into "..\third party libraries\${PACKAGE}" from ${SVN_REPOSITORY}
#
#	Recursively execute CMake on "..\Third Party Libraries\${PACKAGE}\make\cmake 
#
#	Set variables as described at labeled statement <EXPORT PARENT SCOPE VARS>: 
#

# IMPLMENTATION DETAILS:
#
#
# It is currently up to the CMakeLists.txt script of the found package to set
# all the exported PARENT_SCOPE variables.  The current mechanism writes to a
# file call VARS.txt which is then include'd by zjw_find_package.  This was
# necessary because set(... PARENT_SCOPE) is too limited to set variables in a Cmake file's
# parent's parent's parent's scope!
#
# \todo investigate using environment variables to accomplish the above
# \todo add function to 'zjw library.cmake' to automate some of the above
#

# Circa 9/17/09: examples of this are:
#
# - svn://linux01.uncc.edu:3690/zwartell-public/ITCS 6120-8120/OpenGLTrainer/trunk/Source/CMakeLists.txt
# - ... others ...

function(zjw_find_package
		PACKAGE 	    # name of package
		VERSION		    # version of package to find (\todo Unimplemented)
		SVN_REPOSITORY_DIR  # svn repository directory
		TARGET_CONFIG_PATH_SUFFIX # see [R1]
		SHARED_OR_STATIC    # determine whether looking for shared or static library
		TPL_DIR		    # directory for third party libraries
	)
    # check for PACKAGE in TPL_DIR 
    #message(STATUS "Searching for required installation of package: ${PACKAGE}")

    #zjw_compute_conforming_package_url ( ${VERSION} SVN_REPOSITORY_DIR )
    if (SVN_REPOSITORY_DIR MATCHES ".*/trunk")
	# trunk specifically requested, so treat this as special case for now as all my SVN repository
	# directories aren't setup with a tags subdirectory...
    elseif (SVN_REPOSITORY_DIR MATCHES ".*/local/.*")
	# a specific local/ subdirectory requested, treat this as special case for now as all my SVN repository
	# directories aren't setup with a tags subdirectory...
    elseif (NOT SVN_REPOSITORY_DIR STREQUAL "SELF")
	# "standard" case but I'm haven't implement VERSION parameter, so take local/current
        set(SVN_REPOSITORY_DIR "${SVN_REPOSITORY_DIR}local/current")  # temporary hack until above func is done
    endif (SVN_REPOSITORY_DIR MATCHES ".*/trunk")

    #message(STATUS "DIR ${SVN_REPOSITORY_DIR}")
    #return()

    debug_log(2 "SVN_REPOSITORY_DIR ${SVN_REPOSITORY_DIR}")
    debug_log(2 "TPL_DIR ${TPL_DIR}")
    if (${TPL_DIR} MATCHES "^\\..*")
	# relative directory, so compute full path
        debug_log (2 "TPL_DIR ${TPL_DIR}")
        get_filename_component(TPL_DIR_FULL_PATH "${CMAKE_SOURCE_DIR}/${TPL_DIR}" ABSOLUTE)
        debug_log (2 "TPL_DIR_FULL_PATH ${TPL_DIR_FULL_PATH}")
    else (${TPL_DIR} MATCHES "^\\..*")
	set(TPL_DIR_FULL_PATH ${TPL_DIR})
    endif (${TPL_DIR} MATCHES "^\\..*")

    set(PACKAGE_DIR "${TPL_DIR_FULL_PATH}/${PACKAGE}")

    set(PACKAGE_CMAKE_DIR "${PACKAGE_DIR}/make/cmake")
    debug_log (3 "PACKAGE_LIST: $ENV{ZJWL_PACKAGE_LIST}")
    set(MATCHSTR ".*#${PACKAGE}#.*")
    #message(STATUS "MATCHSTR: ${MATCHSTR}")

    if(SVN_REPOSITORY_DIR STREQUAL "SELF")
	# the CMake file calling zjw_find_package is already a part of the saught package, so 
        # ariable is defined because CMake execute already successfully processed a zjw_find_package
	# on this PACKAGE, so skip further processing that would call add_subdirectory
    	message_header(${PACKAGE_DIR})
    	message (STATUS 
	    "The code in:\n"
         "      '${CMAKE_SOURCE_DIR}'\n"
         "   is already part of '${PACKAGE}'.\n" 
	 "      Skipping processing of '${PACKAGE}'...")

        #if(EXISTS "${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
    	if(ZJW_${PACKAGE}_FOUND)
		include ("${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
        #else(EXISTS "${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
    	else(ZJW_${PACKAGE}_FOUND)
		debug_log (2 "PACKAGE_CMAKE_DIR ${PACKAGE_DIR}/make/cmake")
		zjw_cmake_package(${PACKAGE_CMAKE_DIR} ${SHARED_OR_STATIC})

		set(ZJW_${PACKAGE}_FOUND TRUE PARENT_SCOPE)
		set(${PACKAGE}_FOUND TRUE PARENT_SCOPE) # (backwards compatible with CMake find_package)
		include ("${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
        endif(ZJW_${PACKAGE}_FOUND)

    #elseif(EXISTS "${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
    elseif ($ENV{ZJWL_PACKAGE_LIST} MATCHES ${MATCHSTR}) 
	debug_message_header(${PACKAGE_DIR})

	# CMake execute already successfully processed a zjw_find_package
	# on this PACKAGE, so skip further processing that would call add_subdirectory
    	debug_log(1
	    "'${PACKAGE}' already processed once during this execution of Cmake.\n" 
	 "      Skipping re-processing...")

	include ("${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
    #else(EXISTS "${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
    else()
    	message_header(${PACKAGE_DIR})
	if (EXISTS "${PACKAGE_DIR}")
	    # package found, so check compatibility 
	    message(STATUS 
		    "Found installation of package:\n" 
		 "      ${PACKAGE_DIR}\n")

	    zjw_check_for_conforming_package(${PACKAGE} ${VERSION} ${SVN_REPOSITORY_DIR} 
					     ${TARGET_CONFIG_PATH_SUFFIX} ${TPL_DIR} CONFORMANCE)
	    debug_log (2 "Conformance: ${CONFORMANCE}")
	    if (${CONFORMANCE} STREQUAL SUCCESS)
		#found conforming package, so recursively execute CMake
		set(PACKAGE_CMAKE_DIR "${PACKAGE_DIR}/make/cmake")
		message(STATUS 
			"Package conforms to: \n"
	             "         ${SVN_REPOSITORY_DIR}\n"
		     )
		zjw_cmake_package(${PACKAGE_CMAKE_DIR} ${SHARED_OR_STATIC})

		set(ZJW_${PACKAGE}_FOUND TRUE PARENT_SCOPE)
		set(${PACKAGE}_FOUND TRUE PARENT_SCOPE) # (backwards compatible with CMake find_package)
    		set(ENV{ZJWL_PACKAGE_LIST} "$ENV{ZJWL_PACKAGE_LIST}#${PACKAGE}#")

	    	include ("${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
	    elseif (${CONFORMANCE} STREQUAL MISSING_ZJW_CMAKE)
		#missing cmake in package, so warning error
		message(STATUS
		    "*** WARNING ***\n"
		"    Package was retrieved successfully with SVN but it is not fully ZJW Library conforming.\n"
		"    You need to manually compile the package using the vendor's compilation scripts\n"
		"    and then either:\n"
		"       1) Manually set the CMake variables for '${PACKAGE}' as required by the file:\n"
		"  		${CMAKE_PARENT_LIST_FILE}\n"
		"\n"
		"       OR\n"
		"\n"
		"       2) Manually update the native build scripts generated by CMake to link\n"
		"          against the package.\n"
		     )
		set(ZJW_${PACKAGE}_FOUND TRUE PARENT_SCOPE) # this avoids repeating the failed zjw_find_package
    		set(ENV{ZJWL_PACKAGE_LIST} "$ENV{ZJWL_PACKAGE_LIST}#${PACKAGE}#")
		set(${PACKAGE}_FOUND FALSE PARENT_SCOPE) # this indicates error to parent script 

		set(ZJW_${PACKAGE}_RESULT MISSING_ZJW_CMAKE) # calling script must setup variables... 
	    elseif (${CONFORMANCE} STREQUAL WRONG_VERSION)
		if(DEFINED zjw_ignore_version)
		    # this is an advanced optioned (use CMake -D): assume the the found distribution is
		    # compatible despite version difference, so ...
		    zjw_cmake_package(${PACKAGE_CMAKE_DIR} ${SHARED_OR_STATIC})

		    set(ZJW_${PACKAGE}_FOUND TRUE PARENT_SCOPE)
		    set(${PACKAGE}_FOUND TRUE PARENT_SCOPE) # (backwards compatible with CMake find_package)
		    set(ENV{ZJWL_PACKAGE_LIST} "$ENV{ZJWL_PACKAGE_LIST}#${PACKAGE}#")

		    include ("${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
		else(DEFINED zjw_ignore_version)
		    # this is generally for students...
		    message(FATAL_ERROR 
			"Found required package '${PACKAGE_DIR}' but it is the wrong version\n" 
			"The requested version was:\n"
			"   URL: ${SVN_REPOSITORY_DIR}\n"
		        "   VERISION: ${VERSION}\n" 
			)
		endif(DEFINED zjw_ignore_version)
	    else (${CONFORMANCE} STREQUAL WRONG_VERSION)
		#missing conforming package, so fatal error
		#\todo add better instructions for user
		message(FATAL_ERROR "Found required package '${PACKAGE_DIR}' but it is not ZJW Library conforming or "
				    " is wrong version")
	    endif (${CONFORMANCE} STREQUAL SUCCESS)
	else (EXISTS "${PACKAGE_DIR}")
	    # package missing, so perform SVN checkout 

	    # \todo see if there are any good ways of showing the user the progress of the checkout,
	    #    besides dumping the entire SVN output to standard output...
	    #    Unix tail command is good but not portable :(

	    # user feedback
	    message(STATUS "Cannot find required installation of package: '${PACKAGE}'\n"
			"   Retrieving package '${PACKAGE}' using SVN checkout from:\n"
		        "       ${SVN_REPOSITORY_DIR}\n"
			"   and placing in:\n"
			"       ${TPL_DIR}\n"
			"   (This make take several minutes)\n"
		    )

	    # execute SVN
	    execute_process (
		COMMAND svn checkout "${SVN_REPOSITORY_DIR}" "${TPL_DIR}/${PACKAGE}"
		OUTPUT_VARIABLE SVN_OUTPUT
		ERROR_VARIABLE SVN_ERROR
		RESULT_VARIABLE SVN_RESULT
		)

	    # recursively make checkout'ed package 
	    if(${SVN_RESULT} EQUAL 0)
		# SVN success, so resursively CMake the package 
		zjw_check_for_conforming_package(${PACKAGE} ${VERSION} ${SVN_REPOSITORY_DIR} 
						 ${TARGET_CONFIG_PATH_SUFFIX} ${TPL_DIR} FOUND_CONFORMING)
		if (${FOUND_CONFORMING} STREQUAL SUCCESS)
		    #found conforming package, so recursively execute CMake
		    message(STATUS 
			    "SVN checkout package conforms to: \n"
			 "         ${SVN_REPOSITORY_DIR}\n"
			 )
		    set(PACKAGE_CMAKE_DIR "${PACKAGE_DIR}/make/cmake")
		    zjw_cmake_package(${PACKAGE_CMAKE_DIR} ${SHARED_OR_STATIC})

		    set(ZJW_${PACKAGE}_FOUND TRUE PARENT_SCOPE)
    		    set(ENV{ZJWL_PACKAGE_LIST} "$ENV{ZJWL_PACKAGE_LIST}#${PACKAGE}#")
		    set(${PACKAGE}_FOUND TRUE PARENT_SCOPE) # this indicates error to parent script

	    	    include ("${PACKAGE_CMAKE_DIR}/../${MAKE_CONFIG_PATH_SUFFIX}/VARS.txt")
		elseif (${FOUND_CONFORMING} STREQUAL MISSING_ZJW_CMAKE)
		    #missing cmake in package, so warning error
		    message(STATUS
			"*** WARNING ***\n"
		    "    The package '${PACKAGE}' was retrieved successfully with SVN but it is not ZJW Library conforming.\n"
		    "    You need to manually compile the package using the vendor's compilation scripts.\n"
		    "    and then either:\n"
		    "		- manually adjust the CMake generated build scripts to link the installation of '${PACKAGE}'\n"
		    "	     OR\n"
		    "\n"
		    "           - manually set the CMake variables for '${PACKAGE}' as required by the file:\n\n"
		    "  		 ${CMAKE_PARENT_LIST_FILE}\n\n"
		    "		  and then re-run CMake.
		    "		   
		    	 )
		    set(ZJW_${PACKAGE}_FOUND TRUE PARENT_SCOPE) # this avoids repeating the failed zjw_find_package
    		    set(ENV{ZJWL_PACKAGE_LIST} "$ENV{ZJWL_PACKAGE_LIST}#${PACKAGE}#")
		    set(${PACKAGE}_FOUND FALSE) # this indicates error to parent script

		    set(ZJW_${PACKAGE}_RESULT MISSING_ZJW_CMAKE) # calling script must setup variables... 
		endif (${FOUND_CONFORMING} STREQUAL SUCCESS)
	    else(${SVN_RESULT} EQUAL 0)
		# SVN failure, so quit with fatal error
		message(FATAL_ERROR 
		    "Error during SVN checkout.  SVN error message follows:\n"
		  "     ${SVN_ERROR}\n"
		    )
	    endif(${SVN_RESULT} EQUAL 0)
	endif (EXISTS "${PACKAGE_DIR}")
    endif(SVN_REPOSITORY_DIR STREQUAL "SELF")
    
    message(STATUS "\n")

endfunction(zjw_find_package)


#
# \function message_header
#
function(message_header
		PACKAGE_DIR
	)
    message (STATUS "\n")
    message (STATUS 
	    "*******************************************************\n"
	 "   *************      zjw_find_package      **************\n"
	 "   PROCESSING: \n"
	 "         ${PACKAGE_DIR}\n"
	    )
endfunction(message_header)

#
# \function debug_message_header
# 
function(debug_message_header
		PACKAGE_DIR
	)
    if (DEFINED zjw_debug_log)
	if ((1 LESS ${zjw_debug_log}) OR (1 EQUAL ${zjw_debug_log}))
	    message_header(PACKAGE_DIR)	
	endif ()
    endif (DEFINED zjw_debug_log)
endfunction(debug_message_header)

#function(zjw_cmake_package)
#
#
#\todo add error checking, right now this ASSUMES the found
#package is ZJW Library compliant
#
function(zjw_cmake_package
	PACKAGE_CMAKE_DIR
	LIBRARY_TYPE
	)

    message(STATUS 
	    "Recursively executing CMake on:\n"
	"       '${PACKAGE_CMAKE_DIR}'")
    #message(STATUS "Recursively executing CMake on '${MAKE_CONFIG_PATH_SUFFIX}'")
    #execute_process (
    #	COMMAND "cmd" "/c" "dir" ${CMAKE_SOURCE_DIR}/${PACKAGE_CMAKE_DIR}/ )
    set(OLD_BUILD_SHARED_LIBS ${BUILD_SHARED_LIBS})
    if(${LIBRARY_TYPE} STREQUAL SHARED)
    	set(BUILD_SHARED_LIBS TRUE)
    else(${LIBRARY_TYPE} STREQUAL SHARED)
    	set(BUILD_SHARED_LIBS FALSE)
    endif(${LIBRARY_TYPE} STREQUAL SHARED)

    add_subdirectory(${PACKAGE_CMAKE_DIR}
    		     ${PACKAGE_CMAKE_DIR})#/${MAKE_CONFIG_PATH_SUFFIX}/)
    set(BUILD_SHARED_LIBS ${OLD_BUILD_SHARED_LIBS})
endfunction(zjw_cmake_package)

#function(zjw_check_for_conforming_package
#
#\brief Check for a ZJW conforming library package PACKAGE of version VERSION
# that is a working copy from SVN repository SVN_REPOSITORY_DIR and whose
# compilation settings match TARGET_CONFIG_PATH_SUFFIX

#\bug TARGET_CONFIG_PATH_SUFFIX is not yet checked
#
function(zjw_check_for_conforming_package
		PACKAGE 	    # name of package
		VERSION		    # version of package to find
		SVN_REPOSITORY_DIR  # svn repository directory
		TARGET_CONFIG_PATH_SUFFIX # see [R1]
		TPL_DIR		# directory of third party libraries
		CONFORMANCE		
	)

    #check for ZJW Library cmake directory
    debug_log (2 "PACKAGE_CMAKE_DIR ${PACKAGE_DIR}/make/cmake")

    #check for working copy from requested SVN repository directory
    execute_process (
	COMMAND svn info "."
	WORKING_DIRECTORY "${PACKAGE_DIR}"
	OUTPUT_VARIABLE SVN_OUTPUT
	ERROR_VARIABLE SVN_ERROR
	RESULT_VARIABLE SVN_RESULT
	)

    #clean up URL %20 syntax
    string(REPLACE "%20" " " SVN_OUTPUT ${SVN_OUTPUT})
    string(REPLACE "%20" " " SVN_REPOSITORY_DIR ${SVN_REPOSITORY_DIR})

    if (SVN_OUTPUT MATCHES ".*URL: ${SVN_REPOSITORY_DIR}.*")
	#working copy is from the matching SVN repository, so indicate success
	debug_log( 3 "SVN URL match")
    else (SVN_OUTPUT MATCHES ".*URL: ${SVN_REPOSITORY_DIR}.*")
	#working copy is not from the matching SVN repository, so indicate failure 
	debug_log( 3 "NO SVN URL match")

	set(PACKAGE_CMAKE_DIR "${PACKAGE_DIR}/make/cmake")
	if (EXISTS "${PACKAGE_CMAKE_DIR}")
	    debug_log( 2 "${PACKAGE_DIR} : WRONG VERSION" )
	    debug_log( 3 "SVN_OUTPUT:\n ${SVN_OUTPUT}" )
	    set(${CONFORMANCE} WRONG_VERSION PARENT_SCOPE)
	else (EXISTS "${PACKAGE_CMAKE_DIR}")
	    debug_log(2 "${PACKAGE_DIR} : missing zjw cmake")
	    set(${CONFORMANCE} MISSING_ZJW_CMAKE PARENT_SCOPE)
	endif(EXISTS "${PACKAGE_CMAKE_DIR}")
	return()
    endif (SVN_OUTPUT MATCHES ".*URL: ${SVN_REPOSITORY_DIR}.*")

    set(PACKAGE_CMAKE_DIR "${PACKAGE_DIR}/make/cmake")
    if (EXISTS "${PACKAGE_CMAKE_DIR}")
	set(${CONFORMANCE} SUCCESS PARENT_SCOPE)
    else (EXISTS "${PACKAGE_CMAKE_DIR}")
        debug_log(2 "${PACKAGE_DIR} - missing zjw cmake")
	set(${CONFORMANCE} MISSING_ZJW_CMAKE PARENT_SCOPE)
    endif(EXISTS "${PACKAGE_CMAKE_DIR}")
endfunction(zjw_check_for_conforming_package)

# function(zjw_determine_full_config)
#
# Compute make configuration path suffix and target configuration path suffix # (see [R1])
#
# The created variables are:
#
# ${TARGET_CONFIG_PATH_SUFFIX} - 
#    STRING: ${TARGET_OS}/${TARGET_COMPILER}/${TARGET_ARCH}/${TARGET_CRT})
#
# ${MAKE_CONFIG_PATH_SUFFIX}
#   STRING: ${TARGET_OS}/${TARGET_COMPILER}/
#
# ${TARGET_OS}	     - name of host operating system
# ${TARGET_COMPILER} - name of host compiler
# ${TARGET_ARCH}     - name of host CPU architecture
# ${TARGET_CRT}	     - name of target configuration version of C/C++ run-time 
#		       to be linked to
#

function(zjw_determine_full_config)

    if(DEFINED MAKE_CONFIG_PATH_SUFFIX)
	# variable is already defined in parent CMake script, so just re-use the
	# current value
	return()
    endif (DEFINED MAKE_CONFIG_PATH_SUFFIX)

    set (L_TARGET_OS "unknown_OS")
    set (L_TARGET_COMPILER "unknown_compiler")
    set (L_TARGET_ARCH     "unknown_CPU")
    # C/C++ run-time
    set (L_TARGET_CRT      "unknown_CRT")

    if (CMAKE_HOST_WIN32)
	# determine OS
	if ("${CMAKE_HOST_SYSTEM_VERSION}" EQUAL 7.0)
	    set(L_TARGET_OS "Win7")
	elseif ("${CMAKE_HOST_SYSTEM_VERSION}" EQUAL 6.0)
	    set(L_TARGET_OS "Vista")
	elseif("${CMAKE_HOST_SYSTEM_VERSION}" EQUAL 5.1)
	    set(L_TARGET_OS "XP")
	elseif("${CMAKE_HOST_SYSTEM_VERSION}" EQUAL 5.0)
	    set(L_TARGET_OS "2K")
	endif ("${CMAKE_HOST_SYSTEM_VERSION}" EQUAL 7.0)

	# determine compiler/linker
	if ("${MSVC_VERSION}" EQUAL 1500)  
	    set(L_TARGET_COMPILER "VS08")              # \todo FIXME: this is a guess
	elseif ("${MSVC_VERSION}" EQUAL 1400)
	    set(L_TARGET_COMPILER "VS05")
	elseif ("${MSVC_VERSION}" EQUAL 1300)
	    set(L_TARGET_COMPILER "VS03")
	else ("${MSVC_VERSION}")
	    MESSAGE(FATAL_ERROR "This file needs to be updated to support other compilers")
	endif ("${MSVC_VERSION}" EQUAL 1500)  


	# determine CPU architecture
	if (CMAKE_CL_64)
		set(L_TARGET_ARCH "ix86_64")
	else (CMAKE_CL_64)
		set(L_TARGET_ARCH "ix86_32")
	endif(CMAKE_CL_64)

	# determine configuration of the standard C/C++ runtime
	#   Note, right now Cmake defaults to Multi-threaded, DLL
	set(L_TARGET_CRT "MT_DLL")

    elseif (CMAKE_HOST_APPLE)
	# \todo extend these to include all aspects of these Apple target
	# configurations
	set(L_TARGET_OS "Apple")
    elseif (CMAKE_HOST_UNIX)
	# \todo extend these to include all aspects of these Unix target
	# configurations

	set(L_TARGET_OS "Unix")
    endif(CMAKE_HOST_WIN32)

    set(MAKE_CONFIG_PATH_SUFFIX ${L_TARGET_OS}/${L_TARGET_COMPILER}/ PARENT_SCOPE)
    set(TARGET_CONFIG_PATH_SUFFIX ${L_TARGET_OS}/${L_TARGET_COMPILER}/${L_TARGET_ARCH}/${L_TARGET_CRT} PARENT_SCOPE)

    debug_log(2 "MAKE_CONFIG_PATH_SUFFIX: ${L_TARGET_OS}/${L_TARGET_COMPILER}/")
    set (TARGET_OS 		L_TARGET_OS PARENT_SCOPE)
    set (TARGET_COMPILER 	L_TARGET_COMPILER PARENT_SCOPE)
    set (TARGET_ARCH     	L_TARGET_ARCH PARENT_SCOPE)
    set (TARGET_CRT      	L_TARGET_CRT PARENT_SCOPE)

endfunction(zjw_determine_full_config)

#
# \function debug_log
#
function(debug_log
		LEVEL
		VAR_STRINGS
	)
    #message(STATUS "debug_log: ${zjw_debug_log}")
    if (DEFINED zjw_debug_log)
	if ((LEVEL LESS ${zjw_debug_log}) OR (LEVEL EQUAL ${zjw_debug_log}))
	    #message(STATUS "${ARGV}")
	    string(REGEX REPLACE "^[0-9]+(.*)" "\\1" STRING ${ARGV})
	    message(STATUS "debug_log:" ${LEVEL} ": " ${STRING})
	endif ()
    endif (DEFINED zjw_debug_log)
endfunction(debug_log)

##
## INITIALIZE ZJW LIBRARY 
##
debug_log(1 "EXECUTING: 'zjw library.cmake: ${ZJW_LIBRARY_CMAKE}\n")
zjw_determine_full_config()

find_program (SVN_COMMAND "svn")
if (${SVN_COMMAND} STREQUAL "SVN_COMMAND-NOTFOUND")
    message (FATAL_ERROR "The svn program could not be found and is required by this CMake script.   Please install svn from http://subversion.tigris.org/")
endif (${SVN_COMMAND} STREQUAL "SVN_COMMAND-NOTFOUND")
#message (${SVN_COMMAND})


# SECTION: GOAL_zjw_find_package
#
# --THE DESCRIPTION BELOW IS THE GOAL FOR FUNCTION zjw_find_package THE CURRENT
#   IMPLEMENTATION DOES NOT YET IMPLEMENT THIS
#
# Algorithm:
#
# Search for the package PACKAGE in the followings locations the given order:
#
#    1) operating system API directories  <\todo>
#    2) TPL_DIR directory
#
# 1) If you find a ZJW conforming package (see [R1]) check it's version.  If it
# does not match VERSION return an error.
#
# 2) If you find a ZJW conforming package (see [R1]) with a binary distribution
# that is target configuration compatible with TARGET_CONFIG_PATH_SUFFIX then
# set various variables that point to the package's include paths, library
# paths and library names (similar to how find_package works)
# 
# 3) If you find a ZJW conforming package with only a source distribution,
# recursively execute CMake on that distributions ZJW conforming CMake files to
# build the native build scripts that build a target configuration compatible
# and then execute step 2.
#
# 4) If you find no ZJW conforming package, then svn checkout from the ZJW SVN
# repository the source code into directory TPL and execute steps 3)
#
# This scheme would remove the idea of having ZJW Library conforming software
# distributions having to SVN externals link the TPL subdirectories to
# appropriate SVN repository directories, since the CMake script would get what
# you need.
#
# Function Argument Details:
#
# VERSION - version syntax is an extension of the standard CMake version syntax
#
#	major[.minor[.patch].tweak][.tag]
#

#	major, mainor, patch, tweak are all integers (as in standard CMake
#	VERSION variables).  tag is an additional optional string that conforms
#	to the C language identifier syntax.

#		SVN_REPOSITORY_DIR/local/current

#	If tag is absent zjw_find_package attempts to find a ZJW Library
#	conforming copy of the package PACKAGE that is a working copy of 
#	SVN repository redirectory:
#
#		${SVN_REPOSITORY_DIR}/local/${VERSION}
#

#	Detail:  Under ZJW Library policy this is a local modification based on the the
#	   vendor's distribution of the VERSION'th version of PACKAGE. The only
#	   modification made to this local copy is the addition of ZJW Library
#	   conforming cmake compilation files.

#	If tag is given, then the assumption is that the indicated SVN
#	repository directory contains source code modifications to the vendor's
#	VERSION'th version beyond the addition of ZJW conforming cmake files.
#	The target SVN repository directory name follows the same rule as above.


# GOAL ALGORITHM:

# Example for Complete Algorithm (I am working towards this implementation):
#
# zjw_find_package(glut 3.7.6.uncc-1
# svn:/linux01.uncc.edu:3690/zwartell-public/vendor/opengl/glut/ "XP/VS
# 80/Ix86_32/MT_DLL" "../third party libraries"

#
# This will search the directory "..\third party libraries" for the package
# glut The package must have be a working copy of SVN repository directory:

# 	svn:/<....>/opengl/glut/local/3.7.6.uncc-1

# If this package exists in "..\Third Party Libraries" then 

#	check for a conforming binary matching "XP/VS 80/Ix86_32/MT_DLL".

#	If found then 
#		we set various variables to refer to the packages appropriate
#		subdirectory.  
#	else if not found
#		we recursively execute CMake on the ZJW conforming Cmake files
#		to create native build files to build that binary.

# If the package does not exist, look in the standard API directories
#	we check for a conforming binary matching "XP/VS 80/Ix86_32/MT_DLL".
#	If found we set various variables to refer to the packages appropriate
#	subdirectory.  If no such binary is found, we recursively execute CMake
#	on the ZJW conforming Cmake files to create native build files to build
#	that binary.

# If neither package exists, then 
#	we SVN checkout into "..\third party libraries" and recursively execute
#	CMake on the ZJW conforming Cmake files
